---
title: "Generating Polygon Measures for Different Hwy Classifications"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Highway classifications

This markdown shows the highway classifications in the source data, which is from the National Highway Planning Network (NHPN)

```{r buildws}
rm(list=ls())
library(sf)
library(dplyr)
library(purrr)
library(mapview)
library(lwgeom)
devtools::load_all(export_all = F)
# get czs
czs <- divDat::czs


# downloaded from
# https://catalog.data.gov/dataset/national-highway-planning-network-nhpn
shp.dir <- "~/R/shapefiles/"
hwys <- st_read(paste0(shp.dir, "National_Highway_Planning_Network-shp/National_Highway_Planning_Network.shp"))
hwys <- hwys %>%
  select(c(div.id = 1, div.name = LNAME, 
           county = CTFIPS,
           SOURCE,  # data source
           F_SYSTEM, FCLASS, # addl hwy classification
           LRSKEY, # Uniquely identifies a route within a state
           SIGNT1, SIGNN1, SIGN1,
           MILES, KM, state = STFIPS, geometry))

# make uniform metered crs -----------------------------------------------
czs <- czs %>% divM::conic.transform()
hwys <- hwys %>% divM::conic.transform()

# build name-geoid place index --------------------------------------------
# plc <- filter(plc , STATEFP  == 42) %>% # (for test state)
plc.ids <- plc$geoid
names(plc.ids) <- plc$name

```

## Polygons & Hwys Markdown

There are a lot of different ways to subset hwys within a place for generating all the measures.
* By route type: "Interstate," "State route," "non-signed other arterial," etc.. (SIGNT1 in data)
* By "Functional classification": --- can get to "limited-access" hwys this way. (FCLASS in data)
* By spatial relationship: Interstates and all hwys (of x type) that intersect hwy

Data dictionary: https://catalog.data.gov/harvest/object/abbbdb04-58a7-426e-b65e-ca1f4ede864b/html/original

Case study for philly:

```{r phl, echo=TRUE}
(phl <- czs[grepl("Philadelphia",czs$cz_name),]) # cz
phl <- phl %>% rename(region.id = cz, region.name = cz_name) %>% mutate(region.type = "cz")
(phlpl <- plc[grepl("Philadelphia",plc$name),]) # place
base_map <- st_boundary(phl) %>% st_union(st_boundary(phlpl)) %>% mapview(color = "#008080")

# possible hwy subsets for philadelphia ----
# all hwys
all <- divM::subset.polys.divs(region = phl,
                               div.sf = hwys) 
# all interstates
int <- divM::subset.polys.divs(phl, hwys,
                               div.identifier.column = "SIGNT1",
                               always.include = "I", 
                               include.intersecting = F) 
 # all interstates and hwys that intersect interstates
tint <- divM::subset.polys.divs(phl,
                                hwys,
                                div.identifier.column = "SIGNT1",
                                always.include = "I",
                                include.intersecting = T)

# all interstates & limited-access arterials
lac <- hwys %>% filter(FCLASS %in% divM::lac_codes |
                          SIGNT1 == "I") # all limited-access
lac <- divM::subset.polys.divs(phl,
                                lac)

# visualize difs
plot(all['SIGN1'], main = "all philly hwys", lwd=2)
plot(int['SIGN1'], main = "all philly interstates", lwd=2)
plot(tint['SIGN1'], main = "all philly interstates+touching",lwd=2)
plot(lac['SIGN1'], main = "all philly LAC",lwd=2)


```

## The linebreak problem

Sometimes a hwy has a minuscule break. For example, zoom in on I676 in Camden.

I run a helper fcn to repair these before generating polygons. The logic of the function is: If a line segment has an endpoint w/in x threshold of another segment, and they have the same hwy identifiers, I  connect the segments.

Default threshold for filling gap is 200 meters.

Below are the 3 interstates in Philadelphia CZ that have these gaps.

```{r fillgaps.viz}

# filling gaps in Philly interstates:
viz.fix <- divM::Fix.all.hwys(int, return.gap.map = T, verbose = T)

viz.fix$I676
viz.fix$I76
viz.fix$I95

```


Create versions of the above hwy subsets that have their gaps filled.
Suffix names with '.c'

```{r fillgaps}
int.c <- suppressWarnings(divM::Fix.all.hwys(int, verbose = F))
tint.c <- suppressWarnings(divM::Fix.all.hwys(tint, verbose = F))
lac.c <- suppressWarnings(divM::Fix.all.hwys(lac, verbose = F))
```


## Creating polygon measures

From here, creating the polygon measure is actually p straightforward. Fcn "polygonal.div" does the work; it takes linear division data and polygonal boundary data. 

Let's see how it looks with the different the hwy subsets and whether or not the gaps are filled.
I use CZ as boundary.

The other core parameter for generating these measures is the area floor--- the minimum size one of the polygon subdivisions must be for it to be counted. By default this is a 1/2 square km.

```{r polys}
# Summary table:
Summary.table <- 
  tibble( gaps_filled = c(FALSE, TRUE)
           ,interstates_only = c(divM::polygonal.div(phl, int)$n.polys,
                                 divM::polygonal.div(phl, int.c)$n.polys)
           ,interstates_intersecting = c(divM::polygonal.div(phl, tint)$n.polys,
                                         divM::polygonal.div(phl, tint.c)$n.polys)
           ,limited_access = c(polygonal.div(phl, lac)$n.polys,
                                 polygonal.div(phl, lac.c)$n.polys)
           )

knitr::kable(Summary.table)

# to view the polygons as map, ask same function to return.sf to map
polygonal.div(phl, lac.c, return.sf = T) %>%
  select("id") %>%
  plot(main = "LAC polygons in philly")


```
# Wrapping Up

To end on a pun, a single function, `Polys.wrapper`, can replicate this whole workflow, of subsetting the hwys, filling the gaps, and generating the polygons. It will pass on any arguments to its wrapped fcns:

```{r wrappup}

Polys.wrapper(phl, lac,
              fill.gaps = T)

```

